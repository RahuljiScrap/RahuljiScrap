{"ast":null,"code":"\"use client\";\n\nfunction ___$insertStyle(css) {\n  if (!css || typeof window === 'undefined') {\n    return;\n  }\n\n  const style = document.createElement('style');\n  style.setAttribute('type', 'text/css');\n  style.innerHTML = css;\n  document.head.appendChild(style);\n  return css;\n}\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar React = require('react');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nvar React__default = /*#__PURE__*/_interopDefaultLegacy(React);\n\n___$insertStyle(\".marquee-container {\\n  overflow-x: hidden !important;\\n  display: flex !important;\\n  flex-direction: row !important;\\n  position: relative;\\n  width: var(--width);\\n  transform: var(--transform);\\n}\\n.marquee-container:hover div {\\n  animation-play-state: var(--pause-on-hover);\\n}\\n.marquee-container:active div {\\n  animation-play-state: var(--pause-on-click);\\n}\\n\\n.overlay {\\n  position: absolute;\\n  width: 100%;\\n  height: 100%;\\n}\\n.overlay::before, .overlay::after {\\n  background: linear-gradient(to right, var(--gradient-color));\\n  content: \\\"\\\";\\n  height: 100%;\\n  position: absolute;\\n  width: var(--gradient-width);\\n  z-index: 2;\\n}\\n.overlay::after {\\n  right: 0;\\n  top: 0;\\n  transform: rotateZ(180deg);\\n}\\n.overlay::before {\\n  left: 0;\\n  top: 0;\\n}\\n\\n.marquee {\\n  flex: 0 0 auto;\\n  min-width: var(--min-width);\\n  z-index: 1;\\n  display: flex;\\n  flex-direction: row;\\n  align-items: center;\\n  animation: scroll var(--duration) linear var(--delay) var(--iteration-count);\\n  animation-play-state: var(--play);\\n  animation-delay: var(--delay);\\n  animation-direction: var(--direction);\\n}\\n@keyframes scroll {\\n  0% {\\n    transform: translateX(0%);\\n  }\\n  100% {\\n    transform: translateX(-100%);\\n  }\\n}\\n\\n.initial-child-container {\\n  flex: 0 0 auto;\\n  display: flex;\\n  min-width: auto;\\n  flex-direction: row;\\n}\\n\\n.child {\\n  transform: var(--transform);\\n}\");\n\nconst Marquee = React.forwardRef(function Marquee(_ref, ref) {\n  let {\n    style = {},\n    className = \"\",\n    autoFill = false,\n    play = true,\n    pauseOnHover = false,\n    pauseOnClick = false,\n    direction = \"left\",\n    speed = 50,\n    delay = 0,\n    loop = 0,\n    gradient = false,\n    gradientColor = [255, 255, 255],\n    gradientWidth = 200,\n    onFinish,\n    onCycleComplete,\n    onMount,\n    children\n  } = _ref;\n  // React Hooks\n  const [containerWidth, setContainerWidth] = React.useState(0);\n  const [marqueeWidth, setMarqueeWidth] = React.useState(0);\n  const [multiplier, setMultiplier] = React.useState(1);\n  const [isMounted, setIsMounted] = React.useState(false);\n  const rootRef = React.useRef(null);\n  const containerRef = ref || rootRef;\n  const marqueeRef = React.useRef(null); // Calculate width of container and marquee and set multiplier\n\n  const calculateWidth = React.useCallback(() => {\n    if (marqueeRef.current && containerRef.current) {\n      const containerRect = containerRef.current.getBoundingClientRect();\n      const marqueeRect = marqueeRef.current.getBoundingClientRect();\n      let containerWidth = containerRect.width;\n      let marqueeWidth = marqueeRect.width; // Swap width and height if direction is up or down\n\n      if (direction === \"up\" || direction === \"down\") {\n        containerWidth = containerRect.height;\n        marqueeWidth = marqueeRect.height;\n      }\n\n      if (autoFill && containerWidth && marqueeWidth) {\n        setMultiplier(marqueeWidth < containerWidth ? Math.ceil(containerWidth / marqueeWidth) : 1);\n      } else {\n        setMultiplier(1);\n      }\n\n      setContainerWidth(containerWidth);\n      setMarqueeWidth(marqueeWidth);\n    }\n  }, [autoFill, containerRef, direction]); // Calculate width and multiplier on mount and on window resize\n\n  React.useEffect(() => {\n    if (!isMounted) return;\n    calculateWidth();\n\n    if (marqueeRef.current && containerRef.current) {\n      const resizeObserver = new ResizeObserver(() => calculateWidth());\n      resizeObserver.observe(containerRef.current);\n      resizeObserver.observe(marqueeRef.current);\n      return () => {\n        if (!resizeObserver) return;\n        resizeObserver.disconnect();\n      };\n    }\n  }, [calculateWidth, containerRef, isMounted]); // Recalculate width when children change\n\n  React.useEffect(() => {\n    calculateWidth();\n  }, [calculateWidth, children]);\n  React.useEffect(() => {\n    setIsMounted(true);\n  }, []); // Runs the onMount callback, if it is a function, when Marquee is mounted.\n\n  React.useEffect(() => {\n    if (typeof onMount === \"function\") {\n      onMount();\n    }\n  }, []); // Animation duration\n\n  const duration = React.useMemo(() => {\n    if (autoFill) {\n      return marqueeWidth * multiplier / speed;\n    } else {\n      return marqueeWidth < containerWidth ? containerWidth / speed : marqueeWidth / speed;\n    }\n  }, [autoFill, containerWidth, marqueeWidth, multiplier, speed]); // Gradient color in an unfinished rgba format\n\n  const rgbaGradientColor = `rgba(${gradientColor[0]}, ${gradientColor[1]}, ${gradientColor[2]}`;\n  const containerStyle = React.useMemo(() => Object.assign(Object.assign({}, style), {\n    [\"--pause-on-hover\"]: !play || pauseOnHover ? \"paused\" : \"running\",\n    [\"--pause-on-click\"]: !play || pauseOnHover && !pauseOnClick || pauseOnClick ? \"paused\" : \"running\",\n    [\"--width\"]: direction === \"up\" || direction === \"down\" ? `100vh` : \"100%\",\n    [\"--transform\"]: direction === \"up\" ? \"rotate(-90deg)\" : direction === \"down\" ? \"rotate(90deg)\" : \"none\"\n  }), [style, play, pauseOnHover, pauseOnClick, direction]);\n  const gradientStyle = React.useMemo(() => ({\n    [\"--gradient-color\"]: `${rgbaGradientColor}, 1), ${rgbaGradientColor}, 0)`,\n    [\"--gradient-width\"]: typeof gradientWidth === \"number\" ? `${gradientWidth}px` : gradientWidth\n  }), [rgbaGradientColor, gradientWidth]);\n  const marqueeStyle = React.useMemo(() => ({\n    [\"--play\"]: play ? \"running\" : \"paused\",\n    [\"--direction\"]: direction === \"left\" ? \"normal\" : \"reverse\",\n    [\"--duration\"]: `${duration}s`,\n    [\"--delay\"]: `${delay}s`,\n    [\"--iteration-count\"]: !!loop ? `${loop}` : \"infinite\",\n    [\"--min-width\"]: autoFill ? `auto` : \"100%\"\n  }), [play, direction, duration, delay, loop, autoFill]);\n  const childStyle = React.useMemo(() => ({\n    [\"--transform\"]: direction === \"up\" ? \"rotate(90deg)\" : direction === \"down\" ? \"rotate(-90deg)\" : \"none\"\n  }), [direction]); // Render {multiplier} number of children\n\n  const multiplyChildren = React.useCallback(multiplier => {\n    return [...Array(Number.isFinite(multiplier) && multiplier >= 0 ? multiplier : 0)].map((_, i) => React__default['default'].createElement(React.Fragment, {\n      key: i\n    }, React.Children.map(children, child => {\n      return React__default['default'].createElement(\"div\", {\n        style: childStyle,\n        className: \"child\"\n      }, child);\n    })));\n  }, [childStyle, children]);\n  return !isMounted ? null : React__default['default'].createElement(\"div\", {\n    ref: containerRef,\n    style: containerStyle,\n    className: \"marquee-container \" + className\n  }, gradient && React__default['default'].createElement(\"div\", {\n    style: gradientStyle,\n    className: \"overlay\"\n  }), React__default['default'].createElement(\"div\", {\n    className: \"marquee\",\n    style: marqueeStyle,\n    onAnimationIteration: onCycleComplete,\n    onAnimationEnd: onFinish\n  }, React__default['default'].createElement(\"div\", {\n    className: \"initial-child-container\",\n    ref: marqueeRef\n  }, React.Children.map(children, child => {\n    return React__default['default'].createElement(\"div\", {\n      style: childStyle,\n      className: \"child\"\n    }, child);\n  })), multiplyChildren(multiplier - 1)), React__default['default'].createElement(\"div\", {\n    className: \"marquee\",\n    style: marqueeStyle\n  }, multiplyChildren(multiplier)));\n});\nexports.default = Marquee;","map":{"version":3,"mappings":"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","names":["Marquee","forwardRef","ref","style","className","autoFill","play","pauseOnHover","pauseOnClick","direction","speed","delay","loop","gradient","gradientColor","gradientWidth","onFinish","onCycleComplete","onMount","children","containerWidth","setContainerWidth","useState","marqueeWidth","setMarqueeWidth","multiplier","setMultiplier","isMounted","setIsMounted","rootRef","useRef","containerRef","marqueeRef","calculateWidth","useCallback","current","containerRect","getBoundingClientRect","marqueeRect","width","height","Math","ceil","useEffect","resizeObserver","ResizeObserver","observe","disconnect","duration","useMemo","rgbaGradientColor","containerStyle","gradientStyle","marqueeStyle","childStyle","multiplyChildren","Array","Number","isFinite","map","_","i","React","Fragment","key","Children","child","onAnimationIteration","onAnimationEnd"],"sources":["/Users/pawankumar/Documents/MyGitHubProject/SwadYukt/node_modules/react-fast-marquee/src/components/Marquee.tsx"],"sourcesContent":["import React, {\n  Fragment,\n  useEffect,\n  useState,\n  useRef,\n  useCallback,\n  useMemo,\n  ReactNode,\n  CSSProperties,\n  FC,\n  forwardRef,\n  Children,\n  MutableRefObject,\n  RefAttributes,\n} from \"react\";\nimport \"./Marquee.scss\";\n\ntype MarqueeProps = {\n  /**\n   * @description Inline style for the container div\n   * @type {CSSProperties}\n   * @default {}\n   */\n  style?: CSSProperties;\n  /**\n   * @description Class name to style the container div\n   * @type {string}\n   * @default \"\"\n   */\n  className?: string;\n  /**\n   * @description Whether to automatically fill blank space in the marquee with copies of the children or not\n   * @type {boolean}\n   * @default false\n   */\n  autoFill?: boolean;\n  /**\n   * @description Whether to play or pause the marquee\n   * @type {boolean}\n   * @default true\n   */\n  play?: boolean;\n  /**\n   * @description Whether to pause the marquee when hovered\n   * @type {boolean}\n   * @default false\n   */\n  pauseOnHover?: boolean;\n  /**\n   * @description Whether to pause the marquee when clicked\n   * @type {boolean}\n   * @default false\n   */\n  pauseOnClick?: boolean;\n  /**\n   * @description The direction the marquee is sliding\n   * @type {\"left\" | \"right\" | \"up\" | \"down\"}\n   * @default \"left\"\n   */\n  direction?: \"left\" | \"right\" | \"up\" | \"down\";\n  /**\n   * @description Speed calculated as pixels/second\n   * @type {number}\n   * @default 50\n   */\n  speed?: number;\n  /**\n   * @description Duration to delay the animation after render, in seconds\n   * @type {number}\n   * @default 0\n   */\n  delay?: number;\n  /**\n   * @description The number of times the marquee should loop, 0 is equivalent to infinite\n   * @type {number}\n   * @default 0\n   */\n  loop?: number;\n  /**\n   * @description Whether to show the gradient or not\n   * @type {boolean}\n   * @default false\n   */\n  gradient?: boolean;\n  /**\n   * @description The rgb color of the gradient as an array of length 3\n   * @type {Array<number>} of length 3\n   * @default [255, 255, 255]\n   */\n  gradientColor?: [number, number, number];\n  /**\n   * @description The width of the gradient on either side\n   * @type {number | string}\n   * @default 200\n   */\n  gradientWidth?: number | string;\n  /**\n   * @description A callback for when the marquee finishes scrolling and stops. Only calls if loop is non-zero.\n   * @type {() => void}\n   * @default null\n   */\n  onFinish?: () => void;\n  /**\n   * @description A callback for when the marquee finishes a loop. Does not call if maximum loops are reached (use onFinish instead).\n   * @type {() => void}\n   * @default null\n   */\n  onCycleComplete?: () => void;\n  /**\n   * @description: A callback function that is invoked once the marquee has finished mounting. It can be utilized to recalculate the page size, if necessary.\n   * @type {() => void}\n   * @default null\n   */\n  onMount?: () => void;\n  /**\n   * @description The children rendered inside the marquee\n   * @type {ReactNode}\n   * @default null\n   */\n  children?: ReactNode;\n} & RefAttributes<HTMLDivElement>;\n\nconst Marquee: FC<MarqueeProps> = forwardRef(function Marquee(\n  {\n    style = {},\n    className = \"\",\n    autoFill = false,\n    play = true,\n    pauseOnHover = false,\n    pauseOnClick = false,\n    direction = \"left\",\n    speed = 50,\n    delay = 0,\n    loop = 0,\n    gradient = false,\n    gradientColor = [255, 255, 255],\n    gradientWidth = 200,\n    onFinish,\n    onCycleComplete,\n    onMount,\n    children,\n  },\n  ref\n) {\n  // React Hooks\n  const [containerWidth, setContainerWidth] = useState(0);\n  const [marqueeWidth, setMarqueeWidth] = useState(0);\n  const [multiplier, setMultiplier] = useState(1);\n  const [isMounted, setIsMounted] = useState(false);\n  const rootRef = useRef<HTMLDivElement>(null);\n  const containerRef = (ref as MutableRefObject<HTMLDivElement>) || rootRef;\n  const marqueeRef = useRef<HTMLDivElement>(null);\n\n  // Calculate width of container and marquee and set multiplier\n  const calculateWidth = useCallback(() => {\n    if (marqueeRef.current && containerRef.current) {\n      const containerRect = containerRef.current.getBoundingClientRect();\n      const marqueeRect = marqueeRef.current.getBoundingClientRect();\n      let containerWidth = containerRect.width;\n      let marqueeWidth = marqueeRect.width;\n\n      // Swap width and height if direction is up or down\n      if (direction === \"up\" || direction === \"down\") {\n        containerWidth = containerRect.height;\n        marqueeWidth = marqueeRect.height;\n      }\n\n      if (autoFill && containerWidth && marqueeWidth) {\n        setMultiplier(\n          marqueeWidth < containerWidth\n            ? Math.ceil(containerWidth / marqueeWidth)\n            : 1\n        );\n      } else {\n        setMultiplier(1);\n      }\n\n      setContainerWidth(containerWidth);\n      setMarqueeWidth(marqueeWidth);\n    }\n  }, [autoFill, containerRef, direction]);\n\n  // Calculate width and multiplier on mount and on window resize\n  useEffect(() => {\n    if (!isMounted) return;\n\n    calculateWidth();\n    if (marqueeRef.current && containerRef.current) {\n      const resizeObserver = new ResizeObserver(() => calculateWidth());\n      resizeObserver.observe(containerRef.current);\n      resizeObserver.observe(marqueeRef.current);\n      return () => {\n        if (!resizeObserver) return;\n        resizeObserver.disconnect();\n      };\n    }\n  }, [calculateWidth, containerRef, isMounted]);\n\n  // Recalculate width when children change\n  useEffect(() => {\n    calculateWidth();\n  }, [calculateWidth, children]);\n\n  useEffect(() => {\n    setIsMounted(true);\n  }, []);\n\n  // Runs the onMount callback, if it is a function, when Marquee is mounted.\n  useEffect(() => {\n    if (typeof onMount === \"function\") {\n      onMount();\n    }\n  }, []);\n\n  // Animation duration\n  const duration = useMemo(() => {\n    if (autoFill) {\n      return (marqueeWidth * multiplier) / speed;\n    } else {\n      return marqueeWidth < containerWidth\n        ? containerWidth / speed\n        : marqueeWidth / speed;\n    }\n  }, [autoFill, containerWidth, marqueeWidth, multiplier, speed]);\n\n  // Gradient color in an unfinished rgba format\n  const rgbaGradientColor = `rgba(${gradientColor[0]}, ${gradientColor[1]}, ${gradientColor[2]}`;\n\n  const containerStyle = useMemo(\n    () => ({\n      ...style,\n      [\"--pause-on-hover\" as string]:\n        !play || pauseOnHover ? \"paused\" : \"running\",\n      [\"--pause-on-click\" as string]:\n        !play || (pauseOnHover && !pauseOnClick) || pauseOnClick\n          ? \"paused\"\n          : \"running\",\n      [\"--width\" as string]:\n        direction === \"up\" || direction === \"down\" ? `100vh` : \"100%\",\n      [\"--transform\" as string]:\n        direction === \"up\"\n          ? \"rotate(-90deg)\"\n          : direction === \"down\"\n            ? \"rotate(90deg)\"\n            : \"none\",\n    }),\n    [style, play, pauseOnHover, pauseOnClick, direction]\n  );\n\n  const gradientStyle = useMemo(\n    () => ({\n      [\"--gradient-color\" as string]: `${rgbaGradientColor}, 1), ${rgbaGradientColor}, 0)`,\n      [\"--gradient-width\" as string]:\n        typeof gradientWidth === \"number\"\n          ? `${gradientWidth}px`\n          : gradientWidth,\n    }),\n    [rgbaGradientColor, gradientWidth]\n  );\n\n  const marqueeStyle = useMemo(\n    () => ({\n      [\"--play\" as string]: play ? \"running\" : \"paused\",\n      [\"--direction\" as string]: direction === \"left\" ? \"normal\" : \"reverse\",\n      [\"--duration\" as string]: `${duration}s`,\n      [\"--delay\" as string]: `${delay}s`,\n      [\"--iteration-count\" as string]: !!loop ? `${loop}` : \"infinite\",\n      [\"--min-width\" as string]: autoFill ? `auto` : \"100%\",\n    }),\n    [play, direction, duration, delay, loop, autoFill]\n  );\n\n  const childStyle = useMemo(\n    () => ({\n      [\"--transform\" as string]:\n        direction === \"up\"\n          ? \"rotate(90deg)\"\n          : direction === \"down\"\n            ? \"rotate(-90deg)\"\n            : \"none\",\n    }),\n    [direction]\n  );\n\n  // Render {multiplier} number of children\n  const multiplyChildren = useCallback(\n    (multiplier: number) => {\n      return [\n        ...Array(\n          Number.isFinite(multiplier) && multiplier >= 0 ? multiplier : 0\n        ),\n      ].map((_, i) => (\n        <Fragment key={i}>\n          {Children.map(children, (child) => {\n            return (\n              <div style={childStyle} className=\"child\">\n                {child}\n              </div>\n            );\n          })}\n        </Fragment>\n      ));\n    },\n    [childStyle, children]\n  );\n\n  return !isMounted ? null : (\n    <div\n      ref={containerRef}\n      style={containerStyle}\n      className={\"marquee-container \" + className}\n    >\n      {gradient && <div style={gradientStyle} className=\"overlay\" />}\n      <div\n        className=\"marquee\"\n        style={marqueeStyle}\n        onAnimationIteration={onCycleComplete}\n        onAnimationEnd={onFinish}\n      >\n        <div className=\"initial-child-container\" ref={marqueeRef}>\n          {Children.map(children, (child) => {\n            return (\n              <div style={childStyle} className=\"child\">\n                {child}\n              </div>\n            );\n          })}\n        </div>\n        {multiplyChildren(multiplier - 1)}\n      </div>\n      <div className=\"marquee\" style={marqueeStyle}>\n        {multiplyChildren(multiplier)}\n      </div>\n    </div>\n  );\n});\n\nexport default Marquee;\n"]},"metadata":{},"sourceType":"script"}